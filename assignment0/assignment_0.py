# -*- coding: utf-8 -*-
"""Assignment_0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HDagbUm1aghBuUVOJh3TIcigXstKKuJi
"""

#1.1
from google.colab import drive
import os
drive.mount('/content/drive', force_remount=True)
drive_directory = '/content/drive/My Drive/NLP_ex0'
os.chdir(drive_directory)
from IPython.display import Image, display
display(Image('enjoying_nlp.png'))

# Commented out IPython magic to ensure Python compatibility.
#1.2
# %cd /content/drive/My Drive/'NLP_ex0'
!pip install transformers
!wget https://en.wikipedia.org/wiki/Smiley#/media/File:SmileyFace.png

#2.1
import numpy as np
import matplotlib.pyplot as plt
x = np.linspace(0, 10, 2)
y = 5 * x - 8
plt.plot(x, y, 'r-', marker='o')
plt.title("y = 5x - 8 (2 points define a line)")
plt.xlabel("x")
plt.ylabel("y")
plt.grid(True)
plt.show()

#2.2
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(0, 10, 25)
y = x**2 + 3*x

plt.plot(x, y)
plt.title("y = x² + 3x")
plt.xlabel("x")
plt.ylabel("y")
plt.grid(True)
plt.show()

#2.3
import numpy as np
import matplotlib.pyplot as plt

# x values in [0, 10]
x = np.linspace(0, 10, 100)

# Gaussian noise (mean 0, std 1)
epsilon = np.random.normal(0, 1, size=x.shape)

# Noisy samples
y_noisy = x**2 + 3*x + epsilon

plt.plot(x, y_noisy, color='red', label='True curve (no noise)', linewidth=2)

plt.title("y = x² + 3x + ε   (ε ~ N(0,1))")
plt.xlabel("x")
plt.ylabel("y")
plt.legend()
plt.grid(True)
plt.show()

#2.4
import numpy as np

# Randomly sample 100 real numbers uniformly in [0, 1)
samples = np.random.random(100)

# Compute empirical mean and variance
mean = np.mean(samples)
variance = np.var(samples)

print("Empirical mean:", mean)
print("Empirical variance:", variance)

#2.5
import numpy as np

# Get the indices of the 10 largest values
top10_indices = np.argpartition(samples, -10)[-10:]

print("Indices of the 10 largest values:", top10_indices)
print("Their values:", samples[top10_indices])

#2.6
import numpy as np
import matplotlib.pyplot as plt

# Define x values in [-10, 10]
x = np.linspace(-10, 10, 400)

# Define the sigmoid function
def sigmoid(x):
    return 1 / (1 + np.exp(-x))

# Compute σ(x), σ(-x), and derivative σ'(x)
f_x = sigmoid(x)
f_negx = sigmoid(-x)
f_prime = f_x * (1 - f_x)  # derivative of sigmoid

# Plot
plt.plot(x, f_x, label='σ(x)')
plt.plot(x, f_negx, label='σ(-x)')
plt.plot(x, f_prime, label="σ'(x) = σ(x)(1 - σ(x))")
plt.title("Sigmoid σ(x), σ(-x), and derivative σ'(x)")
plt.xlabel("x")
plt.ylabel("Value")
plt.legend()
plt.grid(True)
plt.show()

# -----
# Relation between σ(-x) and σ(x):
# σ(-x) = 1 - σ(x)
#
# Derivative of σ(x):
# σ'(x) = σ(x) * (1 - σ(x))

#2.7
import torch

print("Is GPU available?", torch.cuda.is_available())

if torch.cuda.is_available():
    print("GPU name:", torch.cuda.get_device_name(0))
else:
    print("No GPU.")

#2.8 - Already works



#2.9
import torch
# Random *values* in a 3D tensor (shape can be arbitrary, e.g. 3×4×5)
t = torch.rand(3, 4, 5)
print("Before moving:", t.device)

# Move to GPU
t_gpu = t.to('cuda')
print("After moving:", t_gpu.device)
